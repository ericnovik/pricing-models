library(rstan)
library(dplyr)
library(ggplot2)
source('~/PricingEngine/plot_model_pred.R')

#' Function is to summarise the hypothetical revenue
#' and quantities sold at different price points
#' generated by the Stan model in the generated
#' quantities block
#' @param keys vector of PROD_KEYS to use
#' @param probs vector of probabilities for use in stats::quantile
#' @param qoi string either "rev" or "units"
#' @param prices corresponds to hypo_prices element 
#'               of list created by data_updater
create_quants <- function(x, keys, probs, qoi, prices) {
  n_p <- dim(x)[3]
  stopifnot(n_p == length(prices))
  qs <- lapply(probs, function(p) {
    as.vector(t(apply(x, c(2,3), quantile, p)))
  })
  names(qs) <- paste0(qoi,'_q_',100*probs)
  qs <- bind_cols(qs)
  qs$prod_key <- as.vector(sapply(keys, rep, n_p))
  qs$price <- rep(prices, dim(x)[2])
  return(qs)
}

# Directory where posterior samples in csv form dumped
# by cmdstan reside, along with data used to run cmdstan
model_directory <- '/analytics/data/tests/for_eric/weekly_model_run_20170721/'
# File name for posterior samples csv from cmdstan
model_csv_prefix <- 'wkly_mod_20170721_samples_'
# cmdstan posterior samples file suffix, typically csv, 
model_csv_suffix <- '.csv'
# chain id for cmdstan posterior samples files
csv_ind <- 1:7
data_name <- 'wkly_mod_20170721.RDS'

# Create stanfit object from cmdstan csvs 
mod <- read_stan_csv(paste0(model_directory, model_csv_prefix, csv_ind, model_csv_suffix))

model_data <- readRDS(paste0(model_directory,data_name)) ## previoulsy we read data in this way

weekly <- TRUE

if (weekly) {
  data <- model_data$stan_data
  keys = model_data$prod_map %>% arrange(stan_prod) %>% .$prod_key
  latest_prices = model_data$raw_data %>% group_by(prod_key) %>% dplyr::arrange(prod_key, week_of_sunday) %>%
    summarise(current_price = round(last(price))-0.01) 
  N_prods = data$J_g_1 ##g_2 is number of subject in neg binom
} else {
  keys = data$keys
  latest_prices <- data$prices[,data$N]
  N_prods = data$J ##g_2 is number of subject in neg binom
}

hypo_prices <- data$hypo_prices

# Extract posterior samples as a named list from stanfit object
samps <- rstan::extract(mod)

# Mean revenue under each pricing scenario for each book
rev_mean <- apply(samps$rev_hypo,c(2,3), mean)

# Revenue quantiles under each pricing scenario for each book
all_rev <- create_quants(samps$rev_hypo,
                        keys = keys,
                        probs = c(0.1, 0.25, 0.5, 0.75, 0.9),
                        'rev', hypo_prices)

# Mean quantity sold under each pricing scenario for each book
units_curves <- apply(samps$y_hypo,c(2,3), mean)

# Quantity sold quantiles under each pricing scenario for each book
all_units <- create_quants(samps$y_hypo,
                          keys = keys,
                          probs = c(0.1, 0.25, 0.5, 0.75, 0.9),
                         'units', hypo_prices)

# Return the index of the price which maximizes reveneu for each product
# NB: we can use a different pricing scheme, something which maximizes a function of 
# revenue and quantity, choosing the price that maximizes mean revenue is just 
# for illustrative purposes
max_mean_rev_ind <- apply(rev_mean, 1, function(x) which.max(x))
# Return the price which maximizes expecte revenue for each product
max_mean_rev <- hypo_prices[max_mean_rev_ind] ## picks the revenue-maximizing price (simple)

# Calculate the revenue forecast distribution for each product with its respective optimal price
rev_under_optim <- sapply(1:N_prods, function(x) samps$rev_hypo[,x,max_mean_rev_ind[x]])
# Calculate the quantity sold forecast distribution for each product with its respective optimal price
units_under_optim <- sapply(1:N_prods, function(x) samps$y_hypo[,x,max_mean_rev_ind[x]])

# Calculate the total portfolio revenue forecast distribution when each product is at its respective optimal price
rev_under_optim_port <- apply(rev_under_optim, 1, sum)
# Calculate the total portfolio quantity sold forecast distribution when each product is at its respective optimal price
units_under_optim_port <- apply(units_under_optim, 1, sum)

## Distribution of 30-day forward quantity for each product
## at the current (i.e. last observed when the model was run) price point 
units_current_dist <- apply(samps$y_forward, c(1,2), sum)

## Distribution of 30-day forward revenue for each product
## at the current (i.e. last observed when the model was run) price point 
rev_current_dist <- apply(samps$rev_forward, c(1,2), sum)

## Distribution of 30-day forward quantity for portfolio
## under current pricing
units_current_port <- apply(samps$y_forward,1,sum)

## Distribution of 30-day forward revenue for portfolio
# under current pricing
rev_current_port <- apply(samps$rev_forward,1,sum)

# data.frame for summarising the portfolio under optimal pricing
# vs. the current pricing
revenue <- data.frame(condition = c("no change", "max revenue"),
                      rev_mean = NA, rev_q10 = NA, rev_q25 = NA, rev_q50 = NA, rev_q75 = NA, rev_q90 = NA)

# Summary statistics to be returned for each portfolio
sum_port <- function(x) {
  c(mean(x), quantile(x, c(0.1, .25, 0.5, 0.75, .9)))
}

ggplot(data.frame(r=rev_under_optim_port), aes(x=r)) + geom_histogram() + scale_x_log10()

revenue[1, -1] <- sum_port(rev_current_port)
revenue[2, -1] <- sum_port(rev_under_optim_port)
## can add plots for the status quo versus proposed (optimal) pricing

# Data frame to be use in plotting code below
plting_df <- left_join(all_rev, all_units, by = c('prod_key', 'price'))

current_price = latest_prices$current_price
plting_df$current_price <- as.vector(sapply(current_price, rep, length(hypo_prices)))
plting_df$rev_mean <- as.vector(t(rev_mean))

## number of forecast days controlled in Stan model (30 days default, aggregated)
plot_model_pred(
  plting_df,
  plot_units = TRUE,
  x_var_name = "price",
  y_var_name = "units_q_50",
  plot_current_price = TRUE,
  plot_50 = TRUE,
  line = TRUE,
  scales_free = TRUE
)

# rev curves, no uncertainty
plot_model_pred(
  filter(plting_df, prod_key %in% sample(unique(plting_df$prod_key), 24)),
  plot_units = FALSE,
  x_var_name = "price",
  y_var_name = "rev_mean",
  plot_current_price = TRUE,
  plot_50 = FALSE,
  line = TRUE
)

# rev curves, 50% uncertainty
plot_model_pred(
  filter(plting_df, prod_key %in% sample(unique(plting_df$prod_key), 24)),
  plot_units = FALSE,
  x_var_name = "price",
  y_var_name = "rev_q_50",
  plot_current_price = TRUE,
  plot_50 = TRUE,
  line = TRUE
)

# rev curves, lower 25th quantile
plot_model_pred(
  plting_df,
  plot_units = FALSE,
  x_var_name = "price",
  y_var_name = "rev_q_25",
  plot_current_price = TRUE,
  plot_50 = FALSE,
  line = TRUE
)
